---
phase: 01-foundation-migration
plan: 02
type: execute
wave: 2
depends_on: ["01-01"]
files_modified:
  - src/types/index.ts
  - src/types/common.ts
  - src/types/schemas/contacts.ts
  - src/types/schemas/invoices.ts
  - src/types/schemas/orders.ts
  - src/types/schemas/quotes.ts
  - src/shared/errors.ts
  - src/shared/response.ts
  - src/bexio-client.ts
  - src/tools/index.ts
  - src/server.ts
autonomous: true

must_haves:
  truths:
    - "Types are organized by domain (contacts, invoices, orders, quotes)"
    - "No single file exceeds 200 lines"
    - "Shared utilities exist for error handling and response formatting"
    - "Tool aggregation pattern is established via tools/index.ts"
  artifacts:
    - path: "src/types/index.ts"
      provides: "Barrel export for all types"
      exports: ["PaginationParams", "BexioConfig"]
    - path: "src/shared/errors.ts"
      provides: "McpError class for tool errors"
      contains: "class McpError"
    - path: "src/shared/response.ts"
      provides: "Response formatting utilities"
      contains: "formatResponse"
    - path: "src/tools/index.ts"
      provides: "Tool aggregation for registration"
      contains: "getAllToolDefinitions"
    - path: "src/bexio-client.ts"
      provides: "Bexio API client"
      contains: "class BexioClient"
  key_links:
    - from: "src/server.ts"
      to: "src/tools/index.ts"
      via: "import getAllToolDefinitions"
      pattern: "import.*tools"
    - from: "src/tools/index.ts"
      to: "src/tools/*/index.ts"
      via: "aggregates domain tools"
      pattern: "from.*\\./"
---

<objective>
Create the modular architecture structure that will house all 56 tools in domain-organized modules.

Purpose: The v1 server.ts is 2,418 lines and unmaintainable. This plan creates the directory structure, shared utilities, and aggregation patterns that will make adding tools clean and modular. Each domain module should be <200 lines.

Output: Complete directory structure with types/, shared/, tools/ directories, BexioClient, and aggregation patterns. No tools are migrated yet (that's Plan 03).
</objective>

<execution_context>
@C:\Users\calvi\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\calvi\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@D:\AI\Bexio MCP v2\.planning\PROJECT.md
@D:\AI\Bexio MCP v2\.planning\research\SUMMARY.md
@D:\AI\Bexio MCP v2\.planning\phases\01-foundation-migration\01-01-SUMMARY.md

# v1 reference files (for type extraction)
@D:\AI\Bexio MCP v2\mcp_bexio-main-v1\src\types.ts
@D:\AI\Bexio MCP v2\mcp_bexio-main-v1\src\bexio-client.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create types directory with domain-organized schemas</name>
  <files>
    D:\AI\Bexio MCP v2\src\types\index.ts
    D:\AI\Bexio MCP v2\src\types\common.ts
    D:\AI\Bexio MCP v2\src\types\schemas\contacts.ts
    D:\AI\Bexio MCP v2\src\types\schemas\invoices.ts
    D:\AI\Bexio MCP v2\src\types\schemas\orders.ts
    D:\AI\Bexio MCP v2\src\types\schemas\quotes.ts
    D:\AI\Bexio MCP v2\src\types\schemas\index.ts
  </files>
  <action>
Split the v1 types.ts (700+ lines) into domain-organized modules:

1. Create `src/types/common.ts`:
   - BexioConfig interface
   - PaginationParams interface
   - BexioApiResponse<T> interface
   - SearchCriteriaSchema (Zod)
   - Keep under 50 lines

2. Create `src/types/schemas/contacts.ts`:
   - ListContactsParamsSchema
   - GetContactParamsSchema
   - SearchContactsParamsSchema
   - AdvancedSearchContactsParamsSchema
   - FindContactByNumberParamsSchema
   - FindContactByNameParamsSchema
   - UpdateContactParamsSchema
   - ContactSearchParams interface
   - Export all schemas and inferred types

3. Create `src/types/schemas/invoices.ts`:
   - InvoicePositionSchema
   - InvoiceCreateSchema
   - ListInvoicesParamsSchema
   - ListAllInvoicesParamsSchema
   - GetInvoiceParamsSchema
   - SearchInvoicesParamsSchema
   - SearchInvoicesByCustomerParamsSchema
   - CreateInvoiceParamsSchema
   - ListInvoiceStatusesParamsSchema
   - ListAllStatusesParamsSchema
   - IssueInvoiceParamsSchema, CancelInvoiceParamsSchema, etc.
   - InvoiceSearchParams interface

4. Create `src/types/schemas/orders.ts`:
   - OrderCreateSchema
   - ListOrdersParamsSchema
   - GetOrderParamsSchema
   - CreateOrderParamsSchema
   - SearchOrdersParamsSchema
   - SearchOrdersByCustomerParamsSchema
   - CreateInvoiceFromOrderParamsSchema
   - CreateDeliveryFromOrderParamsSchema

5. Create `src/types/schemas/quotes.ts`:
   - ListQuotesParamsSchema
   - GetQuoteParamsSchema
   - CreateQuoteParamsSchema
   - SearchQuotesParamsSchema
   - SearchQuotesByCustomerParamsSchema
   - IssueQuoteParamsSchema, AcceptQuoteParamsSchema, etc.
   - CreateOrderFromQuoteParamsSchema
   - CreateInvoiceFromQuoteParamsSchema

6. Create `src/types/schemas/index.ts`:
   - Barrel export from all schema files
   - Re-export everything for easy imports

7. Create `src/types/index.ts`:
   - Re-export from common.ts
   - Re-export from schemas/index.ts
   - Single import point for all types

**Key patterns:**
- Use Zod for all parameter validation (already done in v1)
- Use z.infer<typeof Schema> for TypeScript types
- Keep each file focused on one domain
- Use .passthrough() on objects that may have additional Bexio fields
  </action>
  <verify>
```bash
cd src && npm run type-check
wc -l src/types/**/*.ts
```
Type check should pass. No file should exceed 200 lines.
  </verify>
  <done>
- types/common.ts exists with shared types (<50 lines)
- types/schemas/ contains contacts.ts, invoices.ts, orders.ts, quotes.ts
- types/index.ts barrel exports all types
- npm run type-check passes
- Each file is under 200 lines
  </done>
</task>

<task type="auto">
  <name>Task 2: Create shared utilities for errors and response formatting</name>
  <files>
    D:\AI\Bexio MCP v2\src\shared\errors.ts
    D:\AI\Bexio MCP v2\src\shared\response.ts
    D:\AI\Bexio MCP v2\src\shared\index.ts
  </files>
  <action>
Create shared utilities that will be used by all tool handlers:

1. Create `src/shared/errors.ts`:
   - McpError class that extends Error
   - Properties: code (string), message (string), details (optional object)
   - Static factory methods:
     - McpError.notFound(resource: string, id: string | number)
     - McpError.validation(message: string, details?: object)
     - McpError.bexioApi(message: string, statusCode?: number)
     - McpError.internal(message: string)
   - Error codes should be descriptive for LLM recovery:
     - "NOT_FOUND" with message like "Contact with ID 123 not found. Try listing contacts first."
     - "VALIDATION_ERROR" with specific field issues
     - "BEXIO_API_ERROR" with status code and suggestion
   - Keep under 80 lines

2. Create `src/shared/response.ts`:
   - formatSuccessResponse(toolName: string, data: unknown, meta?: object)
     - Wraps data in MCP content format: { content: [{ type: "text", text: JSON.stringify(...) }] }
     - Adds metadata: source, fetched_at, tool name
     - Adds completion marker for Claude parsing
   - formatErrorResponse(error: McpError | Error)
     - Formats error for MCP: { content: [...], isError: true }
     - Includes recovery suggestions when possible
   - formatListResponse(toolName: string, data: unknown[], hasMore: boolean)
     - Special handling for list/search results with pagination info
   - getDataKey(toolName: string): string
     - Maps tool names to response data keys (list_contacts -> "contacts")
   - Keep under 100 lines

3. Create `src/shared/index.ts`:
   - Barrel export from errors.ts and response.ts

**Key principles:**
- "Logic throws, server catches" - handlers throw McpError, server formats
- Error messages should help LLM self-correct
- Response format matches v1 for backward compatibility
  </action>
  <verify>
```bash
cd src && npm run type-check
wc -l src/shared/*.ts
```
Type check passes. Each file under 100 lines.
  </verify>
  <done>
- shared/errors.ts has McpError class with factory methods
- shared/response.ts has format functions for all response types
- shared/index.ts exports all utilities
- Error messages include recovery suggestions
- All files under 100 lines
  </done>
</task>

<task type="auto">
  <name>Task 3: Create BexioClient and tools aggregation structure</name>
  <files>
    D:\AI\Bexio MCP v2\src\bexio-client.ts
    D:\AI\Bexio MCP v2\src\tools\index.ts
    D:\AI\Bexio MCP v2\src\tools\contacts\index.ts
    D:\AI\Bexio MCP v2\src\tools\contacts\definitions.ts
    D:\AI\Bexio MCP v2\src\tools\contacts\handlers.ts
    D:\AI\Bexio MCP v2\src\server.ts
  </files>
  <action>
Create the BexioClient and establish the tool aggregation pattern:

1. Create `src/bexio-client.ts`:
   - Copy the BexioClient class from v1's bexio-client.ts
   - Keep all existing API methods (contacts, invoices, orders, etc.)
   - Update imports to use new types structure
   - Ensure axios error handling uses McpError
   - This file can be larger (~500 lines) as it's the API layer
   - Use the logger for all logging (no console.log)

2. Create `src/tools/contacts/definitions.ts` (EXAMPLE domain):
   - Export toolDefinitions array of Tool objects
   - Each tool has: name, description, inputSchema
   - Copy definitions from v1 server.ts (lines 265-390 for contacts)
   - Keep under 100 lines

3. Create `src/tools/contacts/handlers.ts` (EXAMPLE domain):
   - Export handlers object: { [toolName: string]: (client: BexioClient, args: unknown) => Promise<unknown> }
   - Each handler parses args with Zod schema, calls BexioClient, returns result
   - Throws McpError on failures
   - Keep under 150 lines

4. Create `src/tools/contacts/index.ts`:
   - Import and re-export { toolDefinitions } from definitions
   - Import and re-export { handlers } from handlers
   - Barrel file, under 10 lines

5. Create `src/tools/index.ts`:
   - Import from each domain module (contacts for now)
   - getAllToolDefinitions(): Tool[] - aggregates all domain definitions
   - getHandler(toolName: string): HandlerFn | undefined - looks up handler
   - createHandlerRegistry(client: BexioClient): Map<string, HandlerFn>
   - This is the single import point for server.ts
   - Keep under 50 lines

6. Update `src/server.ts`:
   - Import { getAllToolDefinitions, createHandlerRegistry } from tools
   - Register all tools using getAllToolDefinitions()
   - Handle tool calls using the handler registry
   - Remove the ping test tool (or keep it in a "system" domain)
   - Keep server.ts under 150 lines

**Pattern for adding new domains later:**
1. Create tools/{domain}/definitions.ts
2. Create tools/{domain}/handlers.ts
3. Create tools/{domain}/index.ts
4. Import in tools/index.ts
  </action>
  <verify>
```bash
cd src && npm run build
wc -l src/server.ts src/tools/index.ts src/tools/contacts/*.ts

# Test that contacts tools are registered
echo '{"jsonrpc":"2.0","id":1,"method":"initialize","params":{"protocolVersion":"2024-11-05","capabilities":{},"clientInfo":{"name":"test","version":"1.0"}}}
{"jsonrpc":"2.0","id":2,"method":"tools/list","params":{}}' | node dist/index.js 2>/dev/null | grep list_contacts
```
Build succeeds. Server returns list_contacts in tools/list response.
  </verify>
  <done>
- bexio-client.ts exists with all v1 API methods
- tools/contacts/ has definitions.ts, handlers.ts, index.ts
- tools/index.ts aggregates all domains
- server.ts uses tool registry pattern (under 150 lines)
- Contacts tools appear in tools/list response
- Pattern is established for adding more domains
  </done>
</task>

</tasks>

<verification>
After all tasks complete:

1. **File count and line lengths:**
   ```bash
   wc -l src/types/**/*.ts src/shared/*.ts src/tools/**/*.ts src/server.ts
   ```
   No file should exceed 200 lines (except bexio-client.ts which can be ~500).

2. **Type check:**
   ```bash
   cd src && npm run type-check
   ```
   Must pass with no errors.

3. **Build:**
   ```bash
   cd src && npm run build
   ```
   Must succeed.

4. **Tool registration:**
   ```bash
   echo '{"jsonrpc":"2.0","id":1,"method":"initialize","params":{"protocolVersion":"2024-11-05","capabilities":{},"clientInfo":{"name":"test","version":"1.0"}}}
   {"jsonrpc":"2.0","id":2,"method":"tools/list","params":{}}' | node dist/index.js 2>/dev/null
   ```
   Should list contacts tools (list_contacts, get_contact, etc.).

5. **No console.log:**
   ```bash
   grep -r "console.log" src/*.ts src/**/*.ts
   ```
   Must return no matches.
</verification>

<success_criteria>
- types/ directory has organized schema files (contacts, invoices, orders, quotes)
- shared/ directory has errors.ts and response.ts utilities
- tools/contacts/ demonstrates the domain module pattern
- tools/index.ts aggregates all tools for registration
- server.ts is under 150 lines and uses tool registry
- All TypeScript compiles without errors
- Contacts tools appear in tools/list response
- McpError provides actionable recovery messages
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation-migration/01-02-SUMMARY.md` using the summary template.

Key information to capture:
- Final line counts for each file
- Number of contacts tools registered
- Pattern documentation for adding new domains
- Any deviations from v1 behavior
</output>
